;; Object semanticdb-project-database-file
;; SEMANTICDB Tags save file
(semanticdb-project-database-file "semanticdb-project-database-file"
  :tables
  (list
    (semanticdb-table "semanticdb-table"
      :major-mode emacs-lisp-mode
      :tags nil
      :file "dumb-jump-autoloads.el"
      :pointmax 357
      :fsize 2378
      :lastmodtime '(23829 52177 0 0)
      :unmatched-syntax nil)
    (semanticdb-table "semanticdb-table"
      :major-mode emacs-lisp-mode
      :tags 
        '( ("etags" include nil nil [1413 1429])
            ("f" include nil nil [1430 1442])
            ("s" include nil nil [1443 1455])
            ("dash" include nil nil [1456 1471])
            ("popup" include nil nil [1472 1488])
            ("dumb-jump" customgroup (:user-visible-flag t) nil [1490 1613])
            ("dumb-jump-mode-map" variable (:default-value (let ((map (make-sparse-keymap))) (define-key map (kbd "C-M-g") (quote dumb-jump-go)) (define-key map (kbd "C-M-p") (quote dumb-jump-back)) (define-key map (kbd "C-M-q") (quote dumb-jump-quick-look)) map)) nil [1630 1859])
            ("dumb-jump-window" variable (:default-value (quote current)) nil [1861 2114])
            ("dumb-jump-use-visible-window" variable (:default-value t) nil [2116 2283])
            ("dumb-jump-selector" variable (:default-value (quote popup)) nil [2285 2567])
            ("dumb-jump-ivy-jump-to-selected-function" variable (:default-value (function dumb-jump-ivy-jump-to-selected)) nil [2569 2725])
            ("dumb-jump-prefer-searcher" variable nil nil [2727 3154])
            ("dumb-jump-force-searcher" variable nil nil [3157 3607])
            ("dumb-jump-grep-prefix" variable (:default-value "LANG=C") nil [3609 3759])
            ("dumb-jump-grep-cmd" variable (:default-value "grep") nil [3761 3893])
            ("dumb-jump-ag-cmd" variable (:default-value "ag") nil [3895 4075])
            ("dumb-jump-rg-cmd" variable (:default-value "rg") nil [4077 4245])
            ("dumb-jump-git-grep-cmd" variable (:default-value "git grep") nil [4247 4428])
            ("dumb-jump-ag-word-boundary" variable (:default-value "(?![a-zA-Z0-9\\?\\*-])") nil [4430 4637])
            ("dumb-jump-rg-word-boundary" variable (:default-value "($|[^a-zA-Z0-9\\?\\*-])") nil [4639 4847])
            ("dumb-jump-git-grep-word-boundary" variable (:default-value "($|[^a-zA-Z0-9\\?\\*-])") nil [4849 5069])
            ("dumb-jump-grep-word-boundary" variable (:default-value "($|[^a-zA-Z0-9\\?\\*-])") nil [5071 5283])
            ("dumb-jump-fallback-regex" variable (:default-value "\\bJJJ\\j") nil [5285 5479])
            ("dumb-jump-fallback-search" variable (:default-value t) nil [5481 5644])
            ("dumb-jump-force-grep" variable nil nil [5646 5771])
            ("dumb-jump-zgrep-cmd" variable (:default-value "zgrep") nil [5773 5932])
            ("dumb-jump-grep-args" variable (:default-value "-REn") nil [5934 6088])
            ("dumb-jump-gnu-grep-args" variable (:default-value "-rEn") nil [6090 6251])
            ("dumb-jump-max-find-time" variable (:default-value 2) nil [6253 6422])
            ("dumb-jump-functions-only" variable nil nil [6424 6541])
            ("dumb-jump-quiet" variable nil nil [6543 6675])
            ("dumb-jump-ignore-context" variable nil nil [6677 6828])
            ("dumb-jump-git-grep-search-untracked" variable (:default-value t) nil [6830 7006])
            ("dumb-jump-find-rules" variable (:default-value (quote ((:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "elisp" :regex "\\((defun|cl-defun)\\s+JJJ\\j" :tests ("(defun test (blah)" "(defun test
" "(cl-defun test (blah)" "(cl-defun test
") :not ("(defun test-asdf (blah)" "(defun test-blah
" "(cl-defun test-asdf (blah)" "(cl-defun test-blah
" "(defun tester (blah)" "(defun test? (blah)" "(defun test- (blah)")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "elisp" :regex "\\(defvar\\b\\s*JJJ\\j" :tests ("(defvar test " "(defvar test
") :not ("(defvar tester" "(defvar test?" "(defvar test-")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "elisp" :regex "\\(defcustom\\b\\s*JJJ\\j" :tests ("(defcustom test " "(defcustom test
") :not ("(defcustom tester" "(defcustom test?" "(defcustom test-")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "elisp" :regex "\\(setq\\b\\s*JJJ\\j" :tests ("(setq test 123)") :not ("setq test-blah 123)" "(setq tester" "(setq test?" "(setq test-")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "elisp" :regex "\\(JJJ\\s+" :tests ("(let ((test 123)))") :not ("(let ((test-2 123)))")) (:type "variable" :supports ("ag" "rg" "git-grep") :language "elisp" :regex "\\((defun|cl-defun)\\s*.+\\(?\\s*JJJ\\j\\s*\\)?" :tests ("(defun blah (test)" "(defun blah (test blah)" "(defun (blah test)") :not ("(defun blah (test-1)" "(defun blah (test-2 blah)" "(defun (blah test-3)")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "scheme" :regex "\\(define\\s+\\(\\s*JJJ\\j" :tests ("(define (test blah)" "(define (test
") :not ("(define test blah" "(define (test-asdf blah)" "(define test (lambda (blah")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "scheme" :regex "\\(define\\s+JJJ\\s*\\(\\s*lambda" :tests ("(define test (lambda (blah" "(define test (lambda
") :not ("(define test blah" "(define test-asdf (lambda (blah)" "(define (test)" "(define (test blah) (lambda (foo")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "scheme" :regex "\\(let\\s+JJJ\\s*(\\(|\\[)*" :tests ("(let test ((blah foo) (bar bas))" "(let test
" "(let test [(foo") :not ("(let ((test blah")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "scheme" :regex "\\(define\\s+JJJ\\j" :tests ("(define test " "(define test
") :not ("(define (test")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "scheme" :regex "(\\(|\\[)\\s*JJJ\\s+" :tests ("(let ((test 'foo" "(let [(test 'foo" "(let [(test 'foo" "(let [[test 'foo" "(let ((blah 'foo) (test 'bar)") :not ("{test foo")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "scheme" :regex "\\(lambda\\s+\\(?[^()]*\\s*JJJ\\j\\s*\\)?" :tests ("(lambda (test)" "(lambda (foo test)" "(lambda test (foo)") :not ("(lambda () test")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "scheme" :regex "\\(define\\s+\\([^()]+\\s*JJJ\\j\\s*\\)?" :tests ("(define (foo test)" "(define (foo test bar)") :not ("(define foo test" "(define (test foo" "(define (test)")) (:type "function" :supports ("ag" "rg" "git-grep") :language "c++" :regex "\\bJJJ(\\s|\\))*\\((\\w|[,&*.<>]|\\s)*(\\))\\s*(const|->|\\{|$)|typedef\\s+(\\w|[(*]|\\s)+JJJ(\\)|\\s)*\\(" :tests ("int test(){" "my_struct (*test)(int a, int b){" "auto MyClass::test ( Builder& reference, ) -> decltype( builder.func() ) {" "int test( int *random_argument) const {" "test::test() {" "typedef int (*test)(int);") :not ("return test();)" "int test(a, b);" "if( test() ) {" "else test();")) (:type "variable" :supports ("ag") :language "c++" :regex "\\b(?!(class\\b|struct\\b|return\\b|else\\b|delete\\b))(\\w+|[,>])([*&]|\\s)+JJJ\\s*(\\[(\\d|\\s)*\\])*\\s*([=,(){;]|:\\s*\\d)|#define\\s+JJJ\\b" :tests ("int test=2;" "char *test;" "int x = 1, test = 2" "int test[20];" "#define test" "typedef int test;" "unsigned int test:2") :not ("return test;" "#define NOT test" "else test=2;")) (:type "type" :supports ("ag" "rg" "git-grep") :language "c++" :regex "\\b(class|struct|enum|union)\\b\\s*JJJ\\b\\s*(final\\s*)?(:((\\s*\\w+\\s*::)*\\s*\\w*\\s*<?(\\s*\\w+\\s*::)*\\w+>?\\s*,*)+)?((\\{|$))|}\\s*JJJ\\b\\s*;" :tests ("typedef struct test {" "enum test {" "} test;" "union test {" "class test final: public Parent1, private Parent2{" "class test : public std::vector<int> {") :not ("union test var;" "struct test function() {")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "clojure" :regex "\\(def\\s+JJJ\\j" :tests ("(def test (foo)")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "clojure" :regex "\\(defn-?\\s+JJJ\\j" :tests ("(defn test [foo]" "(defn- test [foo]") :not ("(defn test? [foo]" "(defn- test? [foo]")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "clojure" :regex "\\(defmacro\\s+JJJ\\j" :tests ("(defmacro test [foo]")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "clojure" :regex "\\(deftask\\s+JJJ\\j" :tests ("(deftask test [foo]")) (:type "type" :supports ("ag" "grep" "rg" "git-grep") :language "clojure" :regex "\\(deftype\\s+JJJ\\j" :tests ("(deftype test [foo]")) (:type "type" :supports ("ag" "grep" "rg" "git-grep") :language "clojure" :regex "\\(defmulti\\s+JJJ\\j" :tests ("(defmulti test fn")) (:type "type" :supports ("ag" "grep" "rg" "git-grep") :language "clojure" :regex "\\(defmethod\\s+JJJ\\j" :tests ("(defmethod test type")) (:type "type" :supports ("ag" "grep" "rg" "git-grep") :language "clojure" :regex "\\(definterface\\s+JJJ\\j" :tests ("(definterface test (foo)")) (:type "type" :supports ("ag" "grep" "rg" "git-grep") :language "clojure" :regex "\\(defprotocol\\s+JJJ\\j" :tests ("(defprotocol test (foo)")) (:type "type" :supports ("ag" "grep" "rg" "git-grep") :language "clojure" :regex "\\(defrecord\\s+JJJ\\j" :tests ("(defrecord test [foo]")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "coffeescript" :regex "^\\s*JJJ\\s*[=:].*[-=]>" :tests ("test = ()  =>" "test= =>" "test = ->" "test=()->" "test : ()  =>" "test: =>" "test : ->" "test:()->") :not ("# test = =>" "test = 1")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "coffeescript" :regex "^\\s*JJJ\\s*[:=][^:=-][^>]+$" :tests ("test = $" "test : [" "test = {" "test = a") :not ("test::a" "test: =>" "test == 1" "# test = 1")) (:type "class" :supports ("ag" "grep" "rg" "git-grep") :language "coffeescript" :regex "^\\s*\\bclass\\s+JJJ" :tests ("class test" "class test extends") :not ("# class")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "objc" :regex "\\)\\s*JJJ(:|\\b|\\s)" :tests ("- (void)test" "- (void)test:(UIAlertView *)alertView") :not ("- (void)testnot" "- (void)testnot:(UIAlertView *)alertView")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "objc" :regex "\\b\\*?JJJ\\s*=[^=\\n]+" :tests ("NSString *test = @\"asdf\"") :not ("NSString *testnot = @\"asdf\"" "NSString *nottest = @\"asdf\"")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "swift" :regex "(let|var)\\s*JJJ\\s*(=|:)[^=:\\n]+" :tests ("let test = 1234" "var test = 1234" "private lazy var test: UITapGestureRecognizer") :not ("if test == 1234:")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "swift" :regex "func\\s*JJJ\\b\\s*\\(" :tests ("func test(asdf)" "func test()") :not ("func testnot(asdf)" "func testnot()")) (:type "type" :supports ("ag" "grep" "rg" "git-grep") :language "swift" :regex "(class|struct)\\s*JJJ\\b\\s*?" :tests ("class test:" "class test: UIWindow") :not ("class testnot:" "class testnot(object):")) (:type "function" :supports ("ag" "rg") :language "csharp" :regex "^\\s*(?:[^=\\W]+\\s+){1,3}JJJ\\s*\\(" :tests ("int test()" "int test(param)" "static int test()" "static int test(param)" "public static MyType test()" "private virtual SomeType test(param)" "static int test()") :not ("test()" "testnot()" "blah = new test()")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "csharp" :regex "\\s*\\bJJJ\\s*=[^=\\n)]+" :tests ("int test = 1234") :not ("if test == 1234:" "int nottest = 44")) (:type "type" :supports ("ag" "grep" "rg" "git-grep") :language "csharp" :regex "(class|interface)\\s*JJJ\\b" :tests ("class test:" "public class test : IReadableChannel, I") :not ("class testnot:" "public class testnot : IReadableChannel, I")) (:type "function" :supports ("ag" "rg") :language "java" :regex "^\\s*(?:[^=\\W]+\\s+){1,3}JJJ\\s*\\(" :tests ("int test()" "int test(param)" "static int test()" "static int test(param)" "public static MyType test()" "private virtual SomeType test(param)" "static int test()") :not ("test()" "testnot()" "blah = new test()")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "java" :regex "\\s*\\bJJJ\\s*=[^=\\n)]+" :tests ("int test = 1234") :not ("if test == 1234:" "int nottest = 44")) (:type "type" :supports ("ag" "grep" "rg" "git-grep") :language "java" :regex "(class|interface)\\s*JJJ\\b" :tests ("class test:" "public class test implements Something") :not ("class testnot:" "public class testnot implements Something")) (:type "function" :supports ("ag" "rg" "git-grep") :language "coq" :regex "\\s*Variable\\s+JJJ\\b" :tests ("Variable test") :not ("Variable testx")) (:type "function" :supports ("ag" "rg" "git-grep") :language "coq" :regex "\\s*Inductive\\s+JJJ\\b" :tests ("Inductive test") :not ("Inductive testx")) (:type "function" :supports ("ag" "rg" "git-grep") :language "coq" :regex "\\s*Lemma\\s+JJJ\\b" :tests ("Lemma test") :not ("Lemma testx")) (:type "function" :supports ("ag" "rg" "git-grep") :language "coq" :regex "\\s*Definition\\s+JJJ\\b" :tests ("Definition test") :not ("Definition testx")) (:type "function" :supports ("ag" "rg" "git-grep") :language "coq" :regex "\\s*Hypothesis\\s+JJJ\\b" :tests ("Hypothesis test") :not ("Hypothesis testx")) (:type "function" :supports ("ag" "rg" "git-grep") :language "coq" :regex "\\s*Theorm\\s+JJJ\\b" :tests ("Theorm test") :not ("Theorm testx")) (:type "function" :supports ("ag" "rg" "git-grep") :language "coq" :regex "\\s*Fixpoint\\s+JJJ\\b" :tests ("Fixpoint test") :not ("Fixpoint testx")) (:type "function" :supports ("ag" "rg" "git-grep") :language "coq" :regex "\\s*Module\\s+JJJ\\b" :tests ("Module test") :not ("Module testx")) (:type "function" :supports ("ag" "rg" "git-grep") :language "coq" :regex "\\s*CoInductive\\s+JJJ\\b" :tests ("CoInductive test") :not ("CoInductive testx")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "python" :regex "\\s*JJJ\\s*=[^=\\n]+" :tests ("test = 1234") :not ("if test == 1234:")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "python" :regex "def\\s*JJJ\\b\\s*\\(" :tests ("	def test(asdf)" "def test()") :not ("	def testnot(asdf)" "def testnot()")) (:type "type" :supports ("ag" "grep" "rg" "git-grep") :language "python" :regex "class\\s*JJJ\\b\\s*\\(?" :tests ("class test(object):" "class test:") :not ("class testnot:" "class testnot(object):")) (:type "variable" :supports ("ag" "rg" "git-grep") :language "ruby" :regex "^\\s*((\\w+[.])*\\w+,\\s*)*JJJ(,\\s*(\\w+[.])*\\w+)*\\s*=([^=>~]|$)" :tests ("test = 1234" "self.foo, test, bar = args") :not ("if test == 1234" "foo_test = 1234")) (:type "function" :supports ("ag" "rg" "git-grep") :language "ruby" :regex "(^|[^\\w.])((private|public|protected)\\s+)?def\\s+(\\w+(::|[.]))*JJJ($|[^\\w|:])" :tests ("def test(foo)" "def test()" "def test foo" "def test; end" "def self.test()" "def MODULE::test()" "private def test") :not ("def test_foo")) (:type "function" :supports ("ag" "rg" "git-grep") :language "ruby" :regex "(^|\\W)define(_singleton|_instance)?_method(\\s|[(])\\s*:JJJ($|[^\\w|:])" :tests ("define_method(:test, &body)" "mod.define_instance_method(:test) { body }")) (:type "type" :supports ("ag" "rg" "git-grep") :language "ruby" :regex "(^|[^\\w.])class\\s+(\\w*::)*JJJ($|[^\\w|:])" :tests ("class test" "class Foo::test")) (:type "type" :supports ("ag" "rg" "git-grep") :language "ruby" :regex "(^|[^\\w.])module\\s+(\\w*::)*JJJ($|[^\\w|:])" :tests ("module test" "module Foo::test")) (:type "variable" :supports ("ag" "rg" "git-grep") :language "crystal" :regex "^\\s*((\\w+[.])*\\w+,\\s*)*JJJ(,\\s*(\\w+[.])*\\w+)*\\s*=([^=>~]|$)" :tests ("test = 1234" "self.foo, test, bar = args") :not ("if test == 1234" "foo_test = 1234")) (:type "function" :supports ("ag" "rg" "git-grep") :language "crystal" :regex "(^|[^\\w.])((private|public|protected)\\s+)?def\\s+(\\w+(::|[.]))*JJJ($|[^\\w|:])" :tests ("def test(foo)" "def test()" "def test foo" "def test; end" "def self.test()" "def MODULE::test()" "private def test") :not ("def test_foo")) (:type "type" :supports ("ag" "rg" "git-grep") :language "crystal" :regex "(^|[^\\w.])class\\s+(\\w*::)*JJJ($|[^\\w|:])" :tests ("class test" "class Foo::test")) (:type "type" :supports ("ag" "rg" "git-grep") :language "crystal" :regex "(^|[^\\w.])module\\s+(\\w*::)*JJJ($|[^\\w|:])" :tests ("module test" "module Foo::test")) (:type "type" :supports ("ag" "rg" "git-grep") :language "crystal" :regex "(^|[^\\w.])struct\\s+(\\w*::)*JJJ($|[^\\w|:])" :tests ("struct test" "struct Foo::test")) (:type "type" :supports ("ag" "rg" "git-grep") :language "crystal" :regex "(^|[^\\w.])alias\\s+(\\w*::)*JJJ($|[^\\w|:])" :tests ("alias test" "alias Foo::test")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "scala" :regex "\\bval\\s*JJJ\\s*=[^=\\n]+" :tests ("val test = 1234") :not ("case test => 1234")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "scala" :regex "\\bvar\\s*JJJ\\s*=[^=\\n]+" :tests ("var test = 1234") :not ("case test => 1234")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "scala" :regex "\\btype\\s*JJJ\\s*=[^=\\n]+" :tests ("type test = 1234") :not ("case test => 1234")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "scala" :regex "\\bdef\\s*JJJ\\s*\\(" :tests ("def test(asdf)" "def test()")) (:type "type" :supports ("ag" "grep" "rg" "git-grep") :language "scala" :regex "class\\s*JJJ\\s*\\(?" :tests ("class test(object)")) (:type "type" :supports ("ag" "grep" "rg" "git-grep") :language "scala" :regex "trait\\s*JJJ\\s*\\(?" :tests ("trait test(object)")) (:type "type" :supports ("ag" "grep" "rg" "git-grep") :language "scala" :regex "object\\s*JJJ\\s*\\(?" :tests ("object test(object)")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "r" :regex "\\bJJJ\\s*=[^=><]" :tests ("test = 1234") :not ("if (test == 1234)")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "r" :regex "\\bJJJ\\s*<-\\s*function" :tests ("test <- function")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "perl" :regex "sub\\s*JJJ\\s*\\{" :tests ("sub test{" "sub test {")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "perl" :regex "JJJ\\s*=\\s*" :tests ("$test = 1234")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "shell" :regex "function\\s*JJJ\\s*" :tests ("function test{" "function test {" "function test () {") :not ("function nottest {")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "shell" :regex "JJJ\\(\\)\\s*\\{" :tests ("test() {") :not ("testx() {")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "shell" :regex "\\bJJJ\\s*=\\s*" :tests ("test = 1234") :not ("blahtest = 1234")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "php" :regex "function\\s*JJJ\\s*\\(" :tests ("function test()" "function test ()")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "php" :regex "(\\s|->|\\$|::)JJJ\\s*=\\s*" :tests ("$test = 1234" "$foo->test = 1234")) (:type "trait" :supports ("ag" "grep" "rg" "git-grep") :language "php" :regex "trait\\s*JJJ\\s*\\{" :tests ("trait test{" "trait test {")) (:type "interface" :supports ("ag" "grep" "rg" "git-grep") :language "php" :regex "interface\\s*JJJ\\s*\\{" :tests ("interface test{" "interface test {")) (:type "class" :supports ("ag" "grep" "rg" "git-grep") :language "php" :regex "class\\s*JJJ\\s*(extends|implements|\\{)" :tests ("class test{" "class test {" "class test extends foo" "class test implements foo")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "faust" :regex "\\bJJJ(\\(.+\\))*\\s*=" :tests ("test = osc + 0.5;" "test(freq) = osc(freq) + 0.5;")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "fortran" :regex "\\s*\\bJJJ\\s*=[^=\\n]+" :tests ("test = 1234") :not ("if (test == 1234)")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "fortran" :regex "\\b(function|subroutine)\\s+JJJ\\b\\s*\\(" :tests ("function test (foo)" "integer function test(foo)" "subroutine test (foo, bar)") :not ("end function test" "end subroutine test")) (:type "type" :supports ("ag" "grep" "rg" "git-grep") :language "fortran" :regex "^\\s*module\\s+JJJ\\s*" :tests ("module test") :not ("end module test")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "go" :regex "\\s*\\bJJJ\\s*=[^=\\n]+" :tests ("test = 1234") :not ("if test == 1234 {")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "go" :regex "\\s*\\bJJJ\\s*:=\\s*" :tests ("test := 1234")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "go" :regex "func\\s+\\([^\\)]*\\)\\s+JJJ\\s*\\(" :tests ("func (s *blah) test(filename string) string {")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "go" :regex "func\\s+JJJ\\s*\\(" :tests ("func test(url string) (string, error)")) (:type "type" :supports ("ag" "grep" "rg" "git-grep") :language "go" :regex "type\\s+JJJ\\s+struct\\s+\\{" :tests ("type test struct {")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "javascript" :regex "(service|factory)\\(['\"]JJJ['\"]" :tags ("angular") :tests ("module.factory('test', [\"$rootScope\", function($rootScope) {")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "javascript" :regex "\\bJJJ\\s*[=:]\\s*\\([^\\)]*\\)\\s+=>" :tags ("es6") :tests ("const test = (foo) => " "test: (foo) => {" "  test: (foo) => {")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "javascript" :regex "\\bJJJ\\s*\\([^()]*\\)\\s*[{]" :tags ("es6") :tests ("test(foo) {" "test (foo){" "test(foo){") :not ("test = blah.then(function(){")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "javascript" :tags ("es6") :regex "class\\s*JJJ\\s*[\\(\\{]" :tests ("class test(object) {" "class test{")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "javascript" :tags ("es6") :regex "class\\s*JJJ\\s+extends" :tests ("class test extends Component{")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "javascript" :regex "\\s*\\bJJJ\\s*=[^=\\n]+" :tests ("test = 1234" "const test = props =>") :not ("if (test === 1234)")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "javascript" :regex "\\bfunction\\b[^\\(]*\\(\\s*[^\\)]*\\bJJJ\\b\\s*,?\\s*\\)?" :tests ("function (test)" "function (test, blah)" "function somefunc(test, blah) {" "function(blah, test)") :not ("function (testLen)" "function (test1, blah)" "function somefunc(testFirst, blah) {" "function(blah, testLast)" "function (Lentest)" "function (blahtest, blah)" "function somefunc(Firsttest, blah) {" "function(blah, Lasttest)")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "javascript" :regex "function\\s*JJJ\\s*\\(" :tests ("function test()" "function test ()")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "javascript" :regex "\\bJJJ\\s*:\\s*function\\s*\\(" :tests ("test: function()")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "javascript" :regex "\\bJJJ\\s*=\\s*function\\s*\\(" :tests ("test = function()")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "julia" :regex "(@noinline|@inline)?\\s*function\\s*JJJ(\\{[^\\}]*\\})?\\(" :tests ("function test()" "@inline function test()" "function test{T}(h)")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "julia" :regex "(@noinline|@inline)?JJJ(\\{[^\\}]*\\})?\\([^\\)]*\\) *=" :tests ("test(a)=1" "test(a,b)=1*8" "@noinline test()=1" "test{T}(x)=x")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "julia" :regex "macro\\s*JJJ\\(" :tests ("macro test(a)=1" " macro test(a,b)=1*8")) (:type "variable" :supports ("ag" "rg") :language "julia" :regex "const\\s+JJJ\\b" :tests ("const test = ")) (:type "type" :supports ("ag" (\, "rg")) :language "julia" :regex "(mutable)?\\s*struct\\s*JJJ" :tests ("struct test")) (:type "type" :supports ("ag" (\, "rg")) :language "julia" :regex "(type|immutable|abstract)\\s*JJJ" :tests ("type test" "immutable test" "abstract test <:Testable")) (:type "module" :supports ("ag") :language "haskell" :regex "^module\\s+JJJ\\s+" :tests ("module Test (exportA, exportB) where")) (:type "top level function" :supports ("ag") :language "haskell" :regex "^\\bJJJ(?!(\\s+::))\\s+((.|\\s)*?)=\\s+" :tests ("test n = n * 2" "test X{..} (Y a b c) 
 bcd 
 =
 x * y" "test ab cd e@Datatype {..} (Another thing, inTheRow) = 
 undefined" "test = runRealBasedMode @ext @ctx identity identity" "test unwrap wrap nr@Naoeu {..} (Action action, specSpecs) = 
    undefined") :not ("nottest n = n * 2" "let testnot x y = x * y" "test $ y z" "let test a o = mda" "test :: Sometype -> AnotherType aoeu kek = undefined")) (:type "type-like" :supports ("ag") :language "haskell" :regex "^\\s*((data(\\s+family)?)|(newtype)|(type(\\s+family)?))\\s+JJJ\\s+" :tests ("newtype Test a = Something { b :: Kek }" "data Test a b = Somecase a | Othercase b" "type family Test (x :: *) (xs :: [*]) :: Nat where" "data family Test " "type Test = TestAlias") :not ("newtype NotTest a = NotTest (Not a)" "data TestNot b = Aoeu")) (:type "(data)type constructor 1" :supports ("ag") :language "haskell" :regex "(data|newtype)\\s{1,3}(?!JJJ\\s+)([^=]{1,40})=((\\s{0,3}JJJ\\s+)|([^=]{0,500}?((?<!(-- ))\\|\\s{0,3}JJJ\\s+)))" :tests ("data Something a = Test { b :: Kek }" "data Mem a = TrueMem { b :: Kek } | Test (Mem Int) deriving Mda" "newtype SafeTest a = Test (Kek a) deriving (YonedaEmbedding)") :not ("data Test = Test { b :: Kek }")) (:type "data/newtype record field" :supports ("ag") :language "haskell" :regex "(data|newtype)([^=]*)=[^=]*?({([^=}]*?)(\\bJJJ)\\s+::[^=}]+})" :tests ("data Mem = Mem { 
 mda :: A 
  , test :: Kek 
 , 
 aoeu :: E 
 }" "data Mem = Mem { 
 test :: A 
  , mda :: Kek 
 , 
 aoeu :: E 
 }" "data Mem = Mem { 
 mda :: A 
  , aoeu :: Kek 
 , 
 test :: E 
 }" "data Mem = Mem { test :: Kek } deriving Mda" "data Mem = Mem { 
 test :: Kek 
 } deriving Mda" "newtype Mem = Mem { 
 test :: Kek 
 } deriving (Eq)" "newtype Mem = Mem { -- | Some docs 
 test :: Kek -- ^ More docs } deriving Eq" "newtype Mem = Mem { test :: Kek } deriving (Eq,Monad)" "newtype NewMem = OldMem { test :: [Tx] }" "newtype BlockHeaderList ssc = BHL
 { test :: ([Aoeu a], [Ssss])
    } deriving (Eq)") :not ("data Heh = Mda { sometest :: Kek, testsome :: Mem }")) (:type "typeclass" :supports ("ag") :language "haskell" :regex "^class\\s+(.+=>\\s*)?JJJ\\s+" :tests ("class (Constr1 m, Constr 2) => Test (Kek a) where" "class  Test  (Veryovka a)  where ") :not ("class Test2 (Kek a) where" "class MakeTest (AoeuTest x y z) where")) (:type "type" :supports ("ag" "rg") :language "ocaml" :regex "^\\s*(and|type)\\s+.*\\bJJJ\\b" :tests ("type test =" "and test =" "type 'a test =" "type ('a, _, 'c) test")) (:type "variable" :supports ("ag" "rg") :language "ocaml" :regex "let\\s+JJJ\\b" :tests ("let test =" "let test x y =")) (:type "variable" :supports ("ag" "rg") :language "ocaml" :regex "let\\s+rec\\s+JJJ\\b" :tests ("let rec test =" "let rec  test x y =")) (:type "variable" :supports ("ag" "rg") :language "ocaml" :regex "\\s*val\\s*\\bJJJ\\b\\s*" :tests ("val test")) (:type "module" :supports ("ag" "rg") :language "ocaml" :regex "^\\s*module\\s*\\bJJJ\\b" :tests ("module test =")) (:type "module" :supports ("ag" "rg") :language "ocaml" :regex "^\\s*module\\s*type\\s*\\bJJJ\\b" :tests ("module type test =")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "lua" :regex "\\s*\\bJJJ\\s*=[^=\\n]+" :tests ("test = 1234") :not ("if test === 1234")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "lua" :regex "\\bfunction\\b[^\\(]*\\(\\s*[^\\)]*\\bJJJ\\b\\s*,?\\s*\\)?" :tests ("function (test)" "function (test, blah)" "function somefunc(test, blah)" "function(blah, test)") :not ("function (testLen)" "function (test1, blah)" "function somefunc(testFirst, blah)" "function(blah, testLast)" "function (Lentest)" "function (blahtest, blah)" "function somefunc(Firsttest, blah)" "function(blah, Lasttest)")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "lua" :regex "function\\s*JJJ\\s*\\(" :tests ("function test()" "function test ()")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "lua" :regex "function\\s*.+[.:]JJJ\\s*\\(" :tests ("function MyClass.test()" "function MyClass.test ()" "function MyClass:test()" "function MyClass:test ()")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "lua" :regex "\\bJJJ\\s*=\\s*function\\s*\\(" :tests ("test = function()")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "lua" :regex "\\b.+\\.JJJ\\s*=\\s*function\\s*\\(" :tests ("MyClass.test = function()")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "rust" :regex "\\blet\\s+(\\([^=\\n]*)?(mut +)?JJJ([^=\\n]*\\))?(:\\s*[^=\\n]+)?\\s*=\\s*[^=\\n]+" :tests ("let test = 1234;" "let test: u32 = 1234;" "let test: Vec<u32> = Vec::new();" "let mut test = 1234;" "let mut test: Vec<u32> = Vec::new();" "let (a, test, b) = (1, 2, 3);" "let (a, mut test, mut b) = (1, 2, 3);" "let (mut a, mut test): (u32, usize) = (1, 2);")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "rust" :regex "\\bconst\\s+JJJ:\\s*[^=\\n]+\\s*=[^=\\n]+" :tests ("const test: u32 = 1234;")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "rust" :regex "\\bstatic\\s+(mut\\s+)?JJJ:\\s*[^=\\n]+\\s*=[^=\\n]+" :tests ("static test: u32 = 1234;" "static mut test: u32 = 1234;")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "rust" :regex "\\bfn\\s+.+\\s*\\((.+,\\s+)?JJJ:\\s*[^=\\n]+\\s*(,\\s*.+)*\\)" :tests ("fn abc(test: u32) -> u32 {" "fn abc(x: u32, y: u32, test: Vec<u32>, z: Vec<Foo>)" "fn abc(x: u32, y: u32, test: &mut Vec<u32>, z: Vec<Foo>)")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "rust" :regex "(if|while)\\s+let\\s+([^=\\n]+)?(mut\\s+)?JJJ([^=\\n\\(]+)?\\s*=\\s*[^=\\n]+" :tests ("if let Some(test) = abc() {" "if let Some(mut test) = abc() {" "if let Ok(test) = abc() {" "if let Ok(mut test) = abc() {" "if let Foo(mut test) = foo {" "if let test = abc() {" "if let Some(test) = abc()" "if let Some((a, test, b)) = abc()" "while let Some(test) = abc() {" "while let Some(mut test) = abc() {" "while let Ok(test) = abc() {" "while let Ok(mut test) = abc() {") :not ("while let test(foo) = abc() {")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "rust" :regex "struct\\s+[^\\n{]+[{][^}]*(\\s*JJJ\\s*:\\s*[^\\n},]+)[^}]*}" :tests ("struct Foo { abc: u32, test: Vec<String>, b: PathBuf }" "struct Foo<T>{test:Vec<T>}" "struct FooBar<'a> { test: Vec<String> }") :not ("struct Foo { abc: u32, b: Vec<String> }" "/// ... construct the equivalent ...
fn abc() {
")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "rust" :regex "enum\\s+[^\\n{]+\\s*[{][^}]*\\bJJJ\\b[^}]*}" :tests ("enum Foo { VariantA, test, VariantB(u32) }" "enum Foo<T> { test(T) }" "enum BadStyle{test}" "enum Foo32 { Bar, testing, test(u8) }") :not ("enum Foo { testing }")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "rust" :regex "\\bfn\\s+JJJ\\s*\\(" :tests ("fn test(asdf: u32)" "fn test()" "pub fn test()")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "rust" :regex "\\bmacro_rules!\\s+JJJ" :tests ("macro_rules! test")) (:type "type" :supports ("ag" "grep" "rg" "git-grep") :language "rust" :regex "struct\\s+JJJ\\s*[{\\(]?" :tests ("struct test(u32, u32)" "struct test;" "struct test { abc: u32, def: Vec<String> }")) (:type "type" :supports ("ag" "grep" "rg" "git-grep") :language "rust" :regex "trait\\s+JJJ\\s*[{]?" :tests ("trait test;" "trait test { fn abc() -> u32; }")) (:type "type" :supports ("ag" "grep" "rg" "git-grep") :language "rust" :regex "\\btype\\s+JJJ([^=\\n]+)?\\s*=[^=\\n]+;" :tests ("type test<T> = Rc<RefCell<T>>;" "type test = Arc<RwLock<Vec<u32>>>;")) (:type "type" :supports ("ag" "grep" "rg" "git-grep") :language "rust" :regex "impl\\s+((\\w+::)*\\w+\\s+for\\s+)?(\\w+::)*JJJ\\s+[{]?" :tests ("impl test {" "impl abc::test {" "impl std::io::Read for test {" "impl std::io::Read for abc::test {")) (:type "type" :supports ("ag" "grep" "rg" "git-grep") :language "rust" :regex "mod\\s+JJJ\\s*[{]?" :tests ("mod test;" "pub mod test {")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "elixir" :regex "\\bdef(p)?\\s+JJJ\\s*[ ,\\(]" :tests ("def test do" "def test, do:" "def test() do" "def test(), do:" "def test(foo, bar) do" "def test(foo, bar), do:" "defp test do" "defp test(), do:")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "elixir" :regex "\\s*JJJ\\s*=[^=\\n]+" :tests ("test = 1234") :not ("if test == 1234")) (:type "module" :supports ("ag" "grep" "rg" "git-grep") :language "elixir" :regex "defmodule\\s+(\\w+\\.)*JJJ\\s+" :tests ("defmodule test do" "defmodule Foo.Bar.test do")) (:type "module" :supports ("ag" "grep" "rg" "git-grep") :language "elixir" :regex "defprotocol\\s+(\\w+\\.)*JJJ\\s+" :tests ("defprotocol test do" "defprotocol Foo.Bar.test do")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "erlang" :regex "^JJJ\\b\\s*\\(" :tests ("test() ->" "test()->" "test(Foo) ->" "test (Foo,Bar) ->" "test(Foo, Bar)->")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "erlang" :regex "\\s*JJJ\\s*=[^:=\\n]+" :tests ("test = 1234") :not ("if test =:= 1234" "if test == 1234")) (:type "module" :supports ("ag" "grep" "rg" "git-grep") :language "erlang" :regex "^-module\\(JJJ\\)" :tests ("-module(test).")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "scss" :regex "@mixin\\sJJJ\\b\\s*\\(" :tests ("@mixin test()")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "scss" :regex "@function\\sJJJ\\b\\s*\\(" :tests ("@function test()")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "scss" :regex "JJJ\\s*:\\s*" :tests ("test  :")) (:type "type" :supports ("ag" "grep" "rg" "git-grep") :language "sml" :regex "\\s*(data)?type\\s+.*\\bJJJ\\b" :tests ("datatype test =" "datatype test=" "datatype 'a test =" "type test =" "type 'a test =" "type 'a test" "type test") :not ("datatypetest =")) (:type "variable" :supports ("ag" "grep" "rg" "git-grep") :language "sml" :regex "\\s*val\\s+\\bJJJ\\b" :tests ("val test =" "val test=" "val test : bool")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "sml" :regex "\\s*fun\\s+\\bJJJ\\b.*\\s*=" :tests ("fun test list =" "fun test (STRING_NIL, a) =" "fun test ((s1,s2): 'a queue) : 'a * 'a queue =" "fun test (var : q) : int =" "fun test f e xs =")) (:type "module" :supports ("ag" "grep" "rg" "git-grep") :language "sml" :regex "\\s*(structure|signature|functor)\\s+\\bJJJ\\b" :tests ("structure test =" "structure test : MYTEST =" "signature test =" "functor test (T:TEST) =" "functor test(T:TEST) =")) (:type "type" :supports ("ag" "grep" "rg" "git-grep") :language "vhdl" :regex "\\s*type\\s+\\bJJJ\\b" :tests ("type test is" "type test  is") :not ("type testing is" "type test2  is")) (:type "type" :supports ("ag" "grep" "rg" "git-grep") :language "vhdl" :regex "\\s*constant\\s+\\bJJJ\\b" :tests ("constant test :" "constant test:") :not ("constant testing " "constant test2:")) (:type "function" :supports ("ag" "grep" "rg" "git-grep") :language "vhdl" :regex "function\\s*\"?JJJ\"?\\s*\\(" :tests ("function test(signal)" "function test (signal)" "function \"test\" (signal)") :not ("function testing(signal")) (:type "command" :supports ("ag" "grep" "rg" "git-grep") :language "tex" :regex "\\\\.*newcommand\\*?\\s*\\{\\s*(\\\\)JJJ\\s*}" :tests ("\\newcommand{\\test}" "\\renewcommand{\\test}" "\\renewcommand*{\\test}" "\\newcommand*{\\test}" "\\renewcommand{ \\test }") :not ("\\test" "test")) (:type "command" :supports ("ag" "grep" "rg" "git-grep") :language "tex" :regex "\\\\.*newcommand\\*?\\s*(\\\\)JJJ\\j" :tests ("\\newcommand\\test {}" "\\renewcommand\\test{}" "\\newcommand \\test") :not ("\\test" "test")) (:type "length" :supports ("ag" "grep" "rg" "git-grep") :language "tex" :regex "\\\\(s)etlength\\s*\\{\\s*(\\\\)JJJ\\s*}" :tests ("\\setlength { \\test}" "\\setlength{\\test}" "\\setlength{\\test}{morecommands}") :not ("\\test" "test")) (:type "counter" :supports ("ag" "grep" "rg" "git-grep") :language "tex" :regex "\\\\newcounter\\{\\s*JJJ\\s*}" :tests ("\\newcounter{test}") :not ("\\test" "test")) (:type "environment" :supports ("ag" "grep" "rg" "git-grep") :language "tex" :regex "\\\\.*newenvironment\\s*\\{\\s*JJJ\\s*}" :tests ("\\newenvironment{test}" "\\newenvironment {test}{morecommands}" "\\lstnewenvironment{test}" "\\newenvironment {test}") :not ("\\test" "test"))))) nil [7008 49295])
            ("dumb-jump-language-file-exts" variable (:default-value (quote ((:language "elisp" :ext "el" :agtype "elisp" :rgtype "elisp") (:language "elisp" :ext "el.gz" :agtype "elisp" :rgtype "elisp") (:language "c++" :ext "c" :agtype "cc" :rgtype "c") (:language "c++" :ext "h" :agtype "cc" :rgtype "c") (:language "c++" :ext "C" :agtype "cpp" :rgtype "cpp") (:language "c++" :ext "H" :agtype "cpp" :rgtype "cpp") (:language "c++" :ext "tpp" :agtype "cpp" :rgtype nil) (:language "c++" :ext "cpp" :agtype "cpp" :rgtype "cpp") (:language "c++" :ext "hpp" :agtype "cpp" :rgtype "cpp") (:language "c++" :ext "cxx" :agtype "cpp" :rgtype "cpp") (:language "c++" :ext "hxx" :agtype "cpp" :rgtype nil) (:language "c++" :ext "cc" :agtype "cpp" :rgtype "cpp") (:language "c++" :ext "hh" :agtype "cpp" :rgtype "cpp") (:language "c++" :ext "c++" :agtype nil :rgtype nil) (:language "c++" :ext "h++" :agtype nil :rgtype nil) (:language "coq" :ext "v" :agtype nil :rgtype nil) (:language "ocaml" :ext "ml" :agtype "ocaml" :rgtype "ocaml") (:language "ocaml" :ext "mli" :agtype "ocaml" :rgtype "ocaml") (:language "ocaml" :ext "mll" :agtype "ocaml" :rgtype "ocaml") (:language "ocaml" :ext "mly" :agtype "ocaml" :rgtype "ocaml") (:language "haskell" :ext "hs" :agtype "haskell" :rgtype "haskell") (:language "haskell" :ext "lhs" :agtype "haskell" :rgtype "haskell") (:language "objc" :ext "m" :agtype "objc" :rgtype "objc") (:language "csharp" :ext "cs" :agtype "csharp" :rgtype "csharp") (:language "java" :ext "java" :agtype "java" :rgtype "java") (:language "julia" :ext "jl" :agtype "julia" :rgtype "julia") (:language "clojure" :ext "clj" :agtype "clojure" :rgtype "clojure") (:language "clojure" :ext "cljc" :agtype "clojure" :rgtype "clojure") (:language "clojure" :ext "cljs" :agtype "clojure" :rgtype "clojure") (:language "clojure" :ext "cljx" :agtype "clojure" :rgtype "clojure") (:language "coffeescript" :ext "coffee" :agtype "coffee" :rgtype "coffeescript") (:language "faust" :ext "dsp" :agtype nil :rgtype nil) (:language "faust" :ext "lib" :agtype nil :rgtype nil) (:language "fortran" :ext "f" :agtype "fortran" :rgtype "fortran") (:language "fortran" :ext "f77" :agtype "fortran" :rgtype "fortran") (:language "fortran" :ext "f90" :agtype "fortran" :rgtype "fortran") (:language "fortran" :ext "f95" :agtype "fortran" :rgtype "fortran") (:language "fortran" :ext "f03" :agtype "fortran" :rgtype "fortran") (:language "fortran" :ext "for" :agtype "fortran" :rgtype "fortran") (:language "fortran" :ext "ftn" :agtype "fortran" :rgtype "fortran") (:language "fortran" :ext "fpp" :agtype "fortran" :rgtype "fortran") (:language "go" :ext "go" :agtype "go" :rgtype "go") (:language "javascript" :ext "js" :agtype "js" :rgtype "js") (:language "javascript" :ext "jsx" :agtype "js" :rgtype "js") (:language "javascript" :ext "vue" :agtype "js" :rgtype "js") (:language "javascript" :ext "html" :agtype "html" :rgtype "html") (:language "javascript" :ext "css" :agtype "css" :rgtype "css") (:language "lisp" :ext "lisp" :agtype "lisp" :rgtype "lisp") (:language "lisp" :ext "lsp" :agtype "lisp" :rgtype "lisp") (:language "lua" :ext "lua" :agtype "lua" :rgtype "lua") (:language "org" :ext "org" :agtype nil :rgtype "org") (:language "perl" :ext "pl" :agtype "perl" :rgtype "perl") (:language "perl" :ext "pm" :agtype "perl" :rgtype "perl") (:language "perl" :ext "pm6" :agtype "perl" :rgtype nil) (:language "perl" :ext "perl" :agtype nil :rgtype "perl") (:language "perl" :ext "plh" :agtype nil :rgtype "perl") (:language "perl" :ext "plx" :agtype nil :rgtype "perl") (:language "perl" :ext "pod" :agtype "perl" :rgtype "pod") (:language "perl" :ext "t" :agtype "perl" :rgtype nil) (:language "php" :ext "php" :agtype "php" :rgtype "php") (:language "php" :ext "php3" :agtype "php" :rgtype "php") (:language "php" :ext "php4" :agtype "php" :rgtype "php") (:language "php" :ext "php5" :agtype "php" :rgtype "php") (:language "php" :ext "phtml" :agtype "php" :rgtype "php") (:language "php" :ext "inc" :agtype "php" :rgtype nil) (:language "python" :ext "py" :agtype "python" :rgtype "py") (:language "r" :ext "R" :agtype "r" :rgtype "r") (:language "r" :ext "r" :agtype "r" :rgtype "r") (:language "r" :ext "Rmd" :agtype "r" :rgtype "r") (:language "r" :ext "Rnw" :agtype "r" :rgtype "r") (:language "r" :ext "Rtex" :agtype "r" :rgtype nil) (:language "r" :ext "Rrst" :agtype "r" :rgtype nil) (:language "crystal" :ext "cr" :agtype "crystal" :rgtype "crystal") (:language "crystal" :ext "ecr" :agtype "crystal" :rgtype nil) (:language "ruby" :ext "rb" :agtype "ruby" :rgtype "ruby") (:language "ruby" :ext "erb" :agtype "ruby" :rgtype nil) (:language "ruby" :ext "haml" :agtype "ruby" :rgtype nil) (:language "ruby" :ext "slim" :agtype "ruby" :rgtype nil) (:language "rust" :ext "rs" :agtype "rust" :rgtype "rust") (:language "scala" :ext "scala" :agtype "scala" :rgtype "scala") (:language "scheme" :ext "scm" :agtype "scheme" :rgtype "lisp") (:language "scheme" :ext "ss" :agtype "scheme" :rgtype "lisp") (:language "scheme" :ext "sld" :agtype "scheme" :rgtype "lisp") (:language "shell" :ext "sh" :agtype nil :rgtype nil) (:language "shell" :ext "bash" :agtype nil :rgtype nil) (:language "shell" :ext "csh" :agtype nil :rgtype nil) (:language "shell" :ext "ksh" :agtype nil :rgtype nil) (:language "shell" :ext "tcsh" :agtype nil :rgtype nil) (:language "sml" :ext "sml" :agtype "sml" :rgtype "sml") (:language "swift" :ext "swift" :agtype nil :rgtype "swift") (:language "tex" :ext "tex" :agtype "tex" :rgtype "tex") (:language "elixir" :ext "ex" :agtype "elixir" :rgtype "elixir") (:language "elixir" :ext "exs" :agtype "elixir" :rgtype "elixir") (:language "elixir" :ext "eex" :agtype "elixir" :rgtype "elixir") (:language "erlang" :ext "erl" :agtype "erlang" :rgtype "erlang") (:language "vhdl" :ext "vhd" :agtype "vhdl" :rgtype "vhdl") (:language "vhdl" :ext "vhdl" :agtype "vhdl" :rgtype "vhdl") (:language "scss" :ext "scss" :agtype "css" :rgtype "css")))) nil [49457 56096])
            ("dumb-jump-language-contexts" variable (:default-value (quote ((:language "javascript" :type "function" :right "^(" :left nil) (:language "javascript" :type "variable" :right nil :left "($") (:language "javascript" :type "variable" :right "^)" :left "($") (:language "javascript" :type "variable" :right "^\\." :left nil) (:language "javascript" :type "variable" :right "^;" :left nil) (:language "perl" :type "function" :right "^(" :left nil) (:language "elisp" :type "function" :right nil :left "($") (:language "elisp" :type "variable" :right "^)" :left nil) (:language "scheme" :type "function" :right nil :left "($") (:language "scheme" :type "variable" :right "^)" :left nil)))) nil [56098 57471])
            ("dumb-jump-project-denoters" variable (:default-value (quote (".dumbjump" ".projectile" ".git" ".hg" ".fslckout" ".bzr" "_darcs" ".svn" "Makefile" "PkgInfo" "-pkg.el"))) nil [57473 57751])
            ("dumb-jump-default-project" variable (:default-value "~") nil [57753 57903])
            ("dumb-jump-project" variable nil nil [57905 58093])
            ("dumb-jump-after-jump-hook" variable nil nil [58095 58216])
            ("dumb-jump-aggressive" variable nil nil [58218 58411])
            ("dumb-jump-debug" variable nil nil [58413 58532])
            ("dumb-jump-message-prin1" function (:arguments ("str" "args")) nil [58535 58711])
            ("dumb-jump--ag-installed?" variable (:default-value (quote unset)) nil [58713 58753])
            ("dumb-jump-ag-installed?" function nil nil [58754 59036])
            ("dumb-jump--rg-installed?" variable (:default-value (quote unset)) nil [59038 59078])
            ("dumb-jump-rg-installed?" function nil nil [59079 59358])
            ("dumb-jump--git-grep-installed?" variable (:default-value (quote unset)) nil [59360 59406])
            ("dumb-jump-git-grep-installed?" function nil nil [59407 59750])
            ("dumb-jump--grep-installed?" variable (:default-value (quote unset)) nil [59752 59794])
            ("dumb-jump-grep-installed?" function nil nil [59795 60315])
            ("dumb-jump-find-start-pos" function (:arguments ("line-in" "look-for" "cur-pos")) nil [60317 60812])
            ("dumb-jump-run-test" function (:arguments ("test" "cmd")) nil [60814 61063])
            ("dumb-jump-run-test-temp-file" function (:arguments ("test" "thefile" "realcmd")) nil [61065 61423])
            ("dumb-jump-run-git-grep-test" function (:arguments ("test" "cmd")) nil [61425 61718])
            ("dumb-jump-run-ag-test" function (:arguments ("test" "cmd")) nil [61720 62059])
            ("dumb-jump-test-grep-rules" function (:arguments ("run-not-tests")) nil [62061 63210])
            ("dumb-jump-test-ag-rules" function (:arguments ("run-not-tests")) nil [63212 64219])
            ("dumb-jump-test-rg-rules" function (:arguments ("run-not-tests")) nil [64221 65221])
            ("dumb-jump-test-git-grep-rules" function (:arguments ("run-not-tests")) nil [65223 66264])
            ("dumb-jump-message" function (:arguments ("str" "args")) nil [66266 66454])
            ("dumb-jump-get-point-context" function (:arguments ("line" "func" "cur-pos")) nil [66456 67009])
            ("dumb-jump-to-selected" function (:arguments ("results" "choices" "selected")) nil [67011 67367])
            ("dumb-jump-helm-persist-action" function (:arguments ("match")) nil [67369 68111])
            ("dumb-jump--format-result" function (:arguments ("proj" "result")) nil [68113 68319])
            ("dumb-jump-ivy-jump-to-selected" function (:arguments ("results" "choices" "proj")) nil [68321 68590])
            ("dumb-jump-prompt-user-for-choice" function (:arguments ("proj" "results")) nil [68592 69581])
            ("dumb-jump-get-project-root" function (:arguments ("filepath")) nil [69583 69874])
            ("dumb-jump-get-config" function (:arguments ("dir")) nil [69876 70226])
            ("dumb-jump-get-language" function (:arguments ("file")) nil [70228 70710])
            ("dumb-jump-get-language-from-mode" function nil nil [70712 71002])
            ("dumb-jump-get-language-by-filename" function (:arguments ("file")) nil [71005 71432])
            ("dumb-jump-issue-result" function (:arguments ("issue")) nil [71434 71649])
            ("dumb-jump-get-results" function (:arguments ("prompt")) nil [71651 72317])
            ("dumb-jump-fetch-shell-results" function (:arguments ("prompt")) nil [72319 72860])
            ("dumb-jump-fetch-file-results" function (:arguments ("prompt")) nil [72862 73381])
            ("dumb-jump-process-symbol-by-lang" function (:arguments ("lang" "look-for")) nil [73383 73774])
            ("dumb-jump-get-point-line" function nil nil [73776 73931])
            ("dumb-jump-get-point-symbol" function nil nil [73933 74198])
            ("dumb-jump-get-lang-by-shell-contents" function (:arguments ("buffer")) nil [74200 74610])
            ("dumb-jump-fetch-results" function (:arguments ("cur-file" "proj-root" "lang" "config" "prompt")) nil [74612 76976])
            ("dumb-jump-back" function (:user-visible-flag t) nil [76993 77213])
            ("dumb-jump-quick-look" function (:user-visible-flag t) nil [77230 77394])
            ("dumb-jump-go-other-window" function (:user-visible-flag t) nil [77411 77603])
            ("dumb-jump-go-current-window" function (:user-visible-flag t) nil [77620 77785])
            ("dumb-jump-go-prefer-external" function (:user-visible-flag t) nil [77802 77953])
            ("dumb-jump-go-prompt" function (:user-visible-flag t) nil [77970 78152])
            ("dumb-jump-go-prefer-external-other-window" function (:user-visible-flag t) nil [78169 78403])
            ("dumb-jump-go" function
               (:user-visible-flag t
                :arguments ("use-tooltip" "prefer-external" "prompt"))
                nil [78420 80257])
            ("dumb-jump-language-comments" variable (:default-value (quote ((:comment "//" :language "c++") (:comment ";" :language "elisp") (:comment "//" :language "javascript") (:comment "--" :language "haskell") (:comment "--" :language "lua") (:comment "//" :language "rust") (:comment "#" :language "julia") (:comment "//" :language "objc") (:comment "//" :language "csharp") (:comment "//" :language "java") (:comment ";" :language "clojure") (:comment "#" :language "coffeescript") (:comment "//" :language "faust") (:comment "!" :language "fortran") (:comment "//" :language "go") (:comment ";" :language "lisp") (:comment "#" :language "perl") (:comment "//" :language "php") (:comment "#" :language "python") (:comment "#" :language "r") (:comment "#" :language "ruby") (:comment "#" :language "crystal") (:comment "//" :language "scala") (:comment ";" :language "scheme") (:comment "#" :language "shell") (:comment "//" :language "swift") (:comment "#" :language "elixir") (:comment "%" :language "erlang") (:comment "%" :language "tex") (:comment "--" :language "vhdl") (:comment "//" :language "scss")))) nil [80259 81637])
            ("dumb-jump-get-comment-by-language" function (:arguments ("lang")) nil [81639 81984])
            ("dumb-jump-filter-no-start-comments" function (:arguments ("results" "lang")) nil [81986 82347])
            ("dumb-jump-handle-results" function (:arguments ("results" "cur-file" "proj-root" "ctx-type" "look-for" "use-tooltip" "prefer-external")) nil [82349 87346])
            ("dumb-jump-read-config" function (:arguments ("root" "config-file")) nil [87348 88960])
            ("dumb-jump-file-modified-p" function (:arguments ("path")) nil [88962 89360])
            ("dumb-jump-result-follow" function (:arguments ("result" "use-tooltip" "proj")) nil [89362 89885])
            ("dumb-jump--result-follow" function (:arguments ("result" "use-tooltip" "proj")) nil [89887 91412])
            ("dumb-jump-goto-file-line" function (:arguments ("thefile" "theline" "pos")) nil [91415 92176])
            ("dumb-jump-current-file-results" function (:arguments ("path" "results")) nil [92178 92349])
            ("dumb-jump-generators-by-searcher" function (:arguments ("searcher")) nil [92351 93757])
            ("dumb-jump-pick-grep-variant" function (:arguments ("proj-root")) nil [93759 94844])
            ("dumb-jump-shell-command-switch" function nil nil [94846 95338])
            ("dumb-jump-run-command" function (:arguments ("look-for" "proj" "regexes" "lang" "exclude-args" "cur-file" "line-num" "parse-fn" "generate-fn")) nil [95389 96946])
            ("dumb-jump-parse-response-line" function (:arguments ("resp-line" "cur-file")) nil [96948 97824])
            ("dumb-jump-parse-response-lines" function (:arguments ("parsed" "cur-file" "cur-line-num")) nil [97826 98521])
            ("dumb-jump-parse-grep-response" function (:arguments ("resp" "cur-file" "cur-line-num")) nil [98523 99037])
            ("dumb-jump-parse-ag-response" function (:arguments ("resp" "cur-file" "cur-line-num")) nil [99039 99366])
            ("dumb-jump-parse-rg-response" function (:arguments ("resp" "cur-file" "cur-line-num")) nil [99368 99695])
            ("dumb-jump-parse-git-grep-response" function (:arguments ("resp" "cur-file" "cur-line-num")) nil [99697 100036])
            ("dumb-jump-re-match" function (:arguments ("re" "s")) nil [100038 100182])
            ("dumb-jump-get-ctx-type-by-language" function (:arguments ("lang" "pt-ctx")) nil [100184 101312])
            ("dumb-jump-get-ext-includes" function (:arguments ("language")) nil [101314 101579])
            ("dumb-jump-arg-joiner" function (:arguments ("prefix" "values")) nil [101581 101831])
            ("dumb-jump-get-contextual-regexes" function (:arguments ("lang" "ctx-type" "searcher")) nil [101833 102374])
            ("dumb-jump-populate-regex" function (:arguments ("it" "look-for" "variant")) nil [102376 103117])
            ("dumb-jump-populate-regexes" function (:arguments ("look-for" "regexes" "variant")) nil [103119 103325])
            ("dumb-jump-generate-ag-command" function (:arguments ("look-for" "cur-file" "proj" "regexes" "lang" "exclude-paths")) nil [103327 104408])
            ("dumb-jump-generate-rg-command" function (:arguments ("look-for" "cur-file" "proj" "regexes" "lang" "exclude-paths")) nil [104410 105295])
            ("dumb-jump-generate-git-grep-command" function (:arguments ("look-for" "cur-file" "proj" "regexes" "lang" "exclude-paths")) nil [105297 106380])
            ("dumb-jump-generate-grep-command" function (:arguments ("look-for" "cur-file" "proj" "regexes" "lang" "exclude-paths")) nil [106382 107298])
            ("dumb-jump-generate-gnu-grep-command" function (:arguments ("look-for" "cur-file" "proj" "regexes" "lang" "exclude-paths")) nil [107300 108210])
            ("dumb-jump-concat-command" function (:arguments ("parts")) nil [108212 108385])
            ("dumb-jump-get-file-exts-by-language" function (:arguments ("language")) nil [108387 108633])
            ("dumb-jump-get-ag-type-by-language" function (:arguments ("language")) nil [108635 109009])
            ("dumb-jump-get-rg-type-by-language" function (:arguments ("language")) nil [109011 109385])
            ("dumb-jump-get-git-grep-type-by-language" function (:arguments ("language")) nil [109387 109767])
            ("dumb-jump-get-rules-by-language" function (:arguments ("language" "searcher")) nil [109769 110456])
            ("define-minor-mode" code nil nil [110473 110612])
            ("dumb-jump" package nil nil [110614 110634]))          
      :file "dumb-jump.el"
      :pointmax 110662
      :fsize 110661
      :lastmodtime '(23829 52177 0 0)
      :unmatched-syntax nil))
  :file "!drive_c!Users!hiros!.emacs.d!elpa!dumb-jump-0.5.2!semantic.cache"
  :semantic-tag-version "2.0"
  :semanticdb-version "2.2")
